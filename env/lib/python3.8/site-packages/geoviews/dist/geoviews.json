{"version":4,"artifacts":[{"module":{"file":"/home/runner/work/geoviews/geoviews/geoviews/dist/lib/index.js","base":"/home/runner/work/geoviews/geoviews/geoviews/dist/lib","base_path":"index.js","canonical":"index","resolution":"ESM","id":"c764d38756","hash":"c764d387562670624c9da140449548667d1588e6dd8d12da2fe04c18f1fadf6b","source":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeoViews = void 0;\nconst tslib_1 = require(\"tslib\");\nconst GeoViews = (0, tslib_1.__importStar)(require(\"./models\"));\nexports.GeoViews = GeoViews;\nconst base_1 = require(\"@bokehjs/base\");\n(0, base_1.register_models)(GeoViews);\n//# sourceMappingURL=index.js.map\n","type":"js","dependency_paths":[["./models","/home/runner/work/geoviews/geoviews/geoviews/dist/lib/models/index.js"]],"dependency_map":[],"exported":[],"externals":[],"shims":[]},"code":{"source":"/* index.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    const tslib_1 = require(\"tslib\");\n    const GeoViews = (0, tslib_1.__importStar)(require(\"b4555bea44\") /* ./models */);\n    exports.GeoViews = GeoViews;\n    const base_1 = require(\"@bokehjs/base\");\n    (0, base_1.register_models)(GeoViews);\n}\n","min_source":"function _(e,s,o,t,b){t();const i=(0,e(\"tslib\").__importStar)(e(\"b4555bea44\"));o.GeoViews=i;(0,e(\"@bokehjs/base\").register_models)(i)}\n//# sourceMappingURL=index.min.js.map","min_map":"{\"version\":3,\"sources\":[\"0\"],\"names\":[\"_\",\"require\",\"module\",\"exports\",\"__esModule\",\"__esExport\",\"GeoViews\",\"__importStar\",\"register_models\"],\"mappings\":\"AAAe,SAASA,EAAEC,EAASC,EAAQC,EAASC,EAAYC,GAC5DD,IACA,MACME,GAAW,EADDL,EAAQ,SACKM,cAAcN,EAAQ,eACnDE,EAAQG,SAAWA,GAEnB,EADeL,EAAQ,iBACZO,iBAAiBF\",\"file\":\"index.min.js\"}"}},{"module":{"file":"/home/runner/work/geoviews/geoviews/geoviews/dist/lib/models/index.js","base":"/home/runner/work/geoviews/geoviews/geoviews/dist/lib","base_path":"models/index.js","canonical":"models/index","resolution":"ESM","id":"b4555bea44","hash":"b4555bea4497cc5bbb2ea67ae1cbd42552a9de3a7d8633abf56c3a7ca693300d","source":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RestoreTool = exports.PolyVertexEditTool = exports.PolyVertexDrawTool = exports.ClearTool = exports.CheckpointTool = void 0;\nvar checkpoint_tool_1 = require(\"./checkpoint_tool\");\nObject.defineProperty(exports, \"CheckpointTool\", { enumerable: true, get: function () { return checkpoint_tool_1.CheckpointTool; } });\nvar clear_tool_1 = require(\"./clear_tool\");\nObject.defineProperty(exports, \"ClearTool\", { enumerable: true, get: function () { return clear_tool_1.ClearTool; } });\nvar poly_draw_1 = require(\"./poly_draw\");\nObject.defineProperty(exports, \"PolyVertexDrawTool\", { enumerable: true, get: function () { return poly_draw_1.PolyVertexDrawTool; } });\nvar poly_edit_1 = require(\"./poly_edit\");\nObject.defineProperty(exports, \"PolyVertexEditTool\", { enumerable: true, get: function () { return poly_edit_1.PolyVertexEditTool; } });\nvar restore_tool_1 = require(\"./restore_tool\");\nObject.defineProperty(exports, \"RestoreTool\", { enumerable: true, get: function () { return restore_tool_1.RestoreTool; } });\n//# sourceMappingURL=index.js.map\n","type":"js","dependency_paths":[["./checkpoint_tool","/home/runner/work/geoviews/geoviews/geoviews/dist/lib/models/checkpoint_tool.js"],["./clear_tool","/home/runner/work/geoviews/geoviews/geoviews/dist/lib/models/clear_tool.js"],["./poly_draw","/home/runner/work/geoviews/geoviews/geoviews/dist/lib/models/poly_draw.js"],["./poly_edit","/home/runner/work/geoviews/geoviews/geoviews/dist/lib/models/poly_edit.js"],["./restore_tool","/home/runner/work/geoviews/geoviews/geoviews/dist/lib/models/restore_tool.js"]],"dependency_map":[],"exported":[{"type":"bindings","bindings":[[null,"CheckpointTool"]],"module":"./checkpoint_tool"},{"type":"bindings","bindings":[[null,"ClearTool"]],"module":"./clear_tool"},{"type":"bindings","bindings":[[null,"PolyVertexDrawTool"]],"module":"./poly_draw"},{"type":"bindings","bindings":[[null,"PolyVertexEditTool"]],"module":"./poly_edit"},{"type":"bindings","bindings":[[null,"RestoreTool"]],"module":"./restore_tool"}],"externals":[],"shims":[]},"code":{"source":"/* models/index.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    var checkpoint_tool_1 = require(\"fc272d6e02\") /* ./checkpoint_tool */;\n    __esExport(\"CheckpointTool\", checkpoint_tool_1.CheckpointTool);\n    var clear_tool_1 = require(\"eddee4057c\") /* ./clear_tool */;\n    __esExport(\"ClearTool\", clear_tool_1.ClearTool);\n    var poly_draw_1 = require(\"8288feb407\") /* ./poly_draw */;\n    __esExport(\"PolyVertexDrawTool\", poly_draw_1.PolyVertexDrawTool);\n    var poly_edit_1 = require(\"5e7ea505ce\") /* ./poly_edit */;\n    __esExport(\"PolyVertexEditTool\", poly_edit_1.PolyVertexEditTool);\n    var restore_tool_1 = require(\"e81e0595cf\") /* ./restore_tool */;\n    __esExport(\"RestoreTool\", restore_tool_1.RestoreTool);\n}\n","min_source":"function _(o,e,l,t,r){t(),r(\"CheckpointTool\",o(\"fc272d6e02\").CheckpointTool),r(\"ClearTool\",o(\"eddee4057c\").ClearTool),r(\"PolyVertexDrawTool\",o(\"8288feb407\").PolyVertexDrawTool),r(\"PolyVertexEditTool\",o(\"5e7ea505ce\").PolyVertexEditTool),r(\"RestoreTool\",o(\"e81e0595cf\").RestoreTool)}\n//# sourceMappingURL=index.min.js.map","min_map":"{\"version\":3,\"sources\":[\"0\"],\"names\":[\"_\",\"require\",\"module\",\"exports\",\"__esModule\",\"__esExport\",\"CheckpointTool\",\"ClearTool\",\"PolyVertexDrawTool\",\"PolyVertexEditTool\",\"RestoreTool\"],\"mappings\":\"AAAsB,SAASA,EAAEC,EAASC,EAAQC,EAASC,EAAYC,GACnED,IAEAC,EAAW,iBADaJ,EAAQ,cACeK,gBAE/CD,EAAW,YADQJ,EAAQ,cACUM,WAErCF,EAAW,qBADOJ,EAAQ,cACmBO,oBAE7CH,EAAW,qBADOJ,EAAQ,cACmBQ,oBAE7CJ,EAAW,cADUJ,EAAQ,cACYS\",\"file\":\"index.min.js\"}"}},{"module":{"file":"/home/runner/work/geoviews/geoviews/geoviews/dist/lib/models/checkpoint_tool.js","base":"/home/runner/work/geoviews/geoviews/geoviews/dist/lib","base_path":"models/checkpoint_tool.js","canonical":"models/checkpoint_tool","resolution":"ESM","id":"fc272d6e02","hash":"fc272d6e02c3f925ec6405bd972c0650fd78d4149617b111e8b898bdbdca7d45","source":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CheckpointTool = exports.CheckpointToolView = void 0;\nconst tslib_1 = require(\"tslib\");\nconst p = (0, tslib_1.__importStar)(require(\"@bokehjs/core/properties\"));\nconst array_1 = require(\"@bokehjs/core/util/array\");\nconst action_tool_1 = require(\"@bokehjs/models/tools/actions/action_tool\");\nclass CheckpointToolView extends action_tool_1.ActionToolView {\n    doit() {\n        const sources = this.model.sources;\n        for (const source of sources) {\n            if (!source.buffer) {\n                source.buffer = [];\n            }\n            let data_copy = {};\n            for (const key in source.data) {\n                const column = source.data[key];\n                const new_column = [];\n                for (const arr of column) {\n                    if (Array.isArray(arr) || (ArrayBuffer.isView(arr))) {\n                        new_column.push((0, array_1.copy)(arr));\n                    }\n                    else {\n                        new_column.push(arr);\n                    }\n                }\n                data_copy[key] = new_column;\n            }\n            source.buffer.push(data_copy);\n        }\n    }\n}\nexports.CheckpointToolView = CheckpointToolView;\nCheckpointToolView.__name__ = \"CheckpointToolView\";\nclass CheckpointTool extends action_tool_1.ActionTool {\n    constructor(attrs) {\n        super(attrs);\n        this.tool_name = \"Checkpoint\";\n        this.icon = \"bk-tool-icon-save\";\n    }\n    static init_CheckpointTool() {\n        this.prototype.default_view = CheckpointToolView;\n        this.define({\n            sources: [p.Array, []],\n        });\n    }\n}\nexports.CheckpointTool = CheckpointTool;\nCheckpointTool.__name__ = \"CheckpointTool\";\nCheckpointTool.__module__ = \"geoviews.models.custom_tools\";\nCheckpointTool.init_CheckpointTool();\n//# sourceMappingURL=checkpoint_tool.js.map\n","type":"js","dependency_paths":[],"dependency_map":[],"exported":[{"type":"named","name":"CheckpointToolView"},{"type":"named","name":"CheckpointTool"}],"externals":[],"shims":[]},"code":{"source":"/* models/checkpoint_tool.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    const tslib_1 = require(\"tslib\");\n    const p = (0, tslib_1.__importStar)(require(\"@bokehjs/core/properties\"));\n    const array_1 = require(\"@bokehjs/core/util/array\");\n    const action_tool_1 = require(\"@bokehjs/models/tools/actions/action_tool\");\n    class CheckpointToolView extends action_tool_1.ActionToolView {\n        doit() {\n            const sources = this.model.sources;\n            for (const source of sources) {\n                if (!source.buffer) {\n                    source.buffer = [];\n                }\n                let data_copy = {};\n                for (const key in source.data) {\n                    const column = source.data[key];\n                    const new_column = [];\n                    for (const arr of column) {\n                        if (Array.isArray(arr) || (ArrayBuffer.isView(arr))) {\n                            new_column.push((0, array_1.copy)(arr));\n                        }\n                        else {\n                            new_column.push(arr);\n                        }\n                    }\n                    data_copy[key] = new_column;\n                }\n                source.buffer.push(data_copy);\n            }\n        }\n    }\n    exports.CheckpointToolView = CheckpointToolView;\n    CheckpointToolView.__name__ = \"CheckpointToolView\";\n    class CheckpointTool extends action_tool_1.ActionTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Checkpoint\";\n            this.icon = \"bk-tool-icon-save\";\n        }\n        static init_CheckpointTool() {\n            this.prototype.default_view = CheckpointToolView;\n            this.define({\n                sources: [p.Array, []],\n            });\n        }\n    }\n    exports.CheckpointTool = CheckpointTool;\n    CheckpointTool.__name__ = \"CheckpointTool\";\n    CheckpointTool.__module__ = \"geoviews.models.custom_tools\";\n    CheckpointTool.init_CheckpointTool();\n}\n","min_source":"function _(o,t,e,s,i){s();const c=(0,o(\"tslib\").__importStar)(o(\"@bokehjs/core/properties\")),n=o(\"@bokehjs/core/util/array\"),r=o(\"@bokehjs/models/tools/actions/action_tool\");class l extends r.ActionToolView{doit(){const o=this.model.sources;for(const t of o){t.buffer||(t.buffer=[]);let o={};for(const e in t.data){const s=t.data[e],i=[];for(const o of s)Array.isArray(o)||ArrayBuffer.isView(o)?i.push((0,n.copy)(o)):i.push(o);o[e]=i}t.buffer.push(o)}}}e.CheckpointToolView=l,l.__name__=\"CheckpointToolView\";class a extends r.ActionTool{constructor(o){super(o),this.tool_name=\"Checkpoint\",this.icon=\"bk-tool-icon-save\"}static init_CheckpointTool(){this.prototype.default_view=l,this.define({sources:[c.Array,[]]})}}e.CheckpointTool=a,a.__name__=\"CheckpointTool\",a.__module__=\"geoviews.models.custom_tools\",a.init_CheckpointTool()}\n//# sourceMappingURL=checkpoint_tool.min.js.map","min_map":"{\"version\":3,\"sources\":[\"0\"],\"names\":[\"_\",\"require\",\"module\",\"exports\",\"__esModule\",\"__esExport\",\"p\",\"__importStar\",\"array_1\",\"action_tool_1\",\"CheckpointToolView\",\"ActionToolView\",\"doit\",\"sources\",\"this\",\"model\",\"source\",\"buffer\",\"data_copy\",\"key\",\"data\",\"column\",\"new_column\",\"arr\",\"Array\",\"isArray\",\"ArrayBuffer\",\"isView\",\"push\",\"copy\",\"__name__\",\"CheckpointTool\",\"ActionTool\",\"constructor\",\"attrs\",\"super\",\"tool_name\",\"icon\",\"init_CheckpointTool\",\"prototype\",\"default_view\",\"define\",\"__module__\"],\"mappings\":\"AAAgC,SAASA,EAAEC,EAASC,EAAQC,EAASC,EAAYC,GAC7ED,IACA,MACME,GAAI,EADML,EAAQ,SACFM,cAAcN,EAAQ,6BACtCO,EAAUP,EAAQ,4BAClBQ,EAAgBR,EAAQ,6CAC9B,MAAMS,UAA2BD,EAAcE,eAC3CC,OACI,MAAMC,EAAUC,KAAKC,MAAMF,QAC3B,IAAK,MAAMG,KAAUH,EAAS,CACrBG,EAAOC,SACRD,EAAOC,OAAS,IAEpB,IAAIC,EAAY,GAChB,IAAK,MAAMC,KAAOH,EAAOI,KAAM,CAC3B,MAAMC,EAASL,EAAOI,KAAKD,GACrBG,EAAa,GACnB,IAAK,MAAMC,KAAOF,EACVG,MAAMC,QAAQF,IAASG,YAAYC,OAAOJ,GAC1CD,EAAWM,MAAK,EAAIpB,EAAQqB,MAAMN,IAGlCD,EAAWM,KAAKL,GAGxBL,EAAUC,GAAOG,EAErBN,EAAOC,OAAOW,KAAKV,KAI/Bf,EAAQO,mBAAqBA,EAC7BA,EAAmBoB,SAAW,qBAC9B,MAAMC,UAAuBtB,EAAcuB,WACvCC,YAAYC,GACRC,MAAMD,GACNpB,KAAKsB,UAAY,aACjBtB,KAAKuB,KAAO,oBAEhBC,6BACIxB,KAAKyB,UAAUC,aAAe9B,EAC9BI,KAAK2B,OAAO,CACR5B,QAAS,CAACP,EAAEkB,MAAO,OAI/BrB,EAAQ4B,eAAiBA,EACzBA,EAAeD,SAAW,iBAC1BC,EAAeW,WAAa,+BAC5BX,EAAeO\",\"file\":\"checkpoint_tool.min.js\"}"}},{"module":{"file":"/home/runner/work/geoviews/geoviews/geoviews/dist/lib/models/clear_tool.js","base":"/home/runner/work/geoviews/geoviews/geoviews/dist/lib","base_path":"models/clear_tool.js","canonical":"models/clear_tool","resolution":"ESM","id":"eddee4057c","hash":"eddee4057cf684ec8fd28824d47a46858cf925e99747f7ecada4162c2764822c","source":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClearTool = exports.ClearToolView = void 0;\nconst tslib_1 = require(\"tslib\");\nconst p = (0, tslib_1.__importStar)(require(\"@bokehjs/core/properties\"));\nconst action_tool_1 = require(\"@bokehjs/models/tools/actions/action_tool\");\nclass ClearToolView extends action_tool_1.ActionToolView {\n    doit() {\n        for (var source of this.model.sources) {\n            for (const column in source.data) {\n                source.data[column] = [];\n            }\n            source.change.emit();\n            source.properties.data.change.emit();\n        }\n    }\n}\nexports.ClearToolView = ClearToolView;\nClearToolView.__name__ = \"ClearToolView\";\nclass ClearTool extends action_tool_1.ActionTool {\n    constructor(attrs) {\n        super(attrs);\n        this.tool_name = \"Clear data\";\n        this.icon = \"bk-tool-icon-reset\";\n    }\n    static init_ClearTool() {\n        this.prototype.default_view = ClearToolView;\n        this.define({\n            sources: [p.Array, []],\n        });\n    }\n}\nexports.ClearTool = ClearTool;\nClearTool.__name__ = \"ClearTool\";\nClearTool.__module__ = \"geoviews.models.custom_tools\";\nClearTool.init_ClearTool();\n//# sourceMappingURL=clear_tool.js.map\n","type":"js","dependency_paths":[],"dependency_map":[],"exported":[{"type":"named","name":"ClearToolView"},{"type":"named","name":"ClearTool"}],"externals":[],"shims":[]},"code":{"source":"/* models/clear_tool.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    const tslib_1 = require(\"tslib\");\n    const p = (0, tslib_1.__importStar)(require(\"@bokehjs/core/properties\"));\n    const action_tool_1 = require(\"@bokehjs/models/tools/actions/action_tool\");\n    class ClearToolView extends action_tool_1.ActionToolView {\n        doit() {\n            for (var source of this.model.sources) {\n                for (const column in source.data) {\n                    source.data[column] = [];\n                }\n                source.change.emit();\n                source.properties.data.change.emit();\n            }\n        }\n    }\n    exports.ClearToolView = ClearToolView;\n    ClearToolView.__name__ = \"ClearToolView\";\n    class ClearTool extends action_tool_1.ActionTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Clear data\";\n            this.icon = \"bk-tool-icon-reset\";\n        }\n        static init_ClearTool() {\n            this.prototype.default_view = ClearToolView;\n            this.define({\n                sources: [p.Array, []],\n            });\n        }\n    }\n    exports.ClearTool = ClearTool;\n    ClearTool.__name__ = \"ClearTool\";\n    ClearTool.__module__ = \"geoviews.models.custom_tools\";\n    ClearTool.init_ClearTool();\n}\n","min_source":"function _(o,e,t,s,i){s();const a=(0,o(\"tslib\").__importStar)(o(\"@bokehjs/core/properties\")),l=o(\"@bokehjs/models/tools/actions/action_tool\");class r extends l.ActionToolView{doit(){for(var o of this.model.sources){for(const e in o.data)o.data[e]=[];o.change.emit(),o.properties.data.change.emit()}}}t.ClearToolView=r,r.__name__=\"ClearToolView\";class n extends l.ActionTool{constructor(o){super(o),this.tool_name=\"Clear data\",this.icon=\"bk-tool-icon-reset\"}static init_ClearTool(){this.prototype.default_view=r,this.define({sources:[a.Array,[]]})}}t.ClearTool=n,n.__name__=\"ClearTool\",n.__module__=\"geoviews.models.custom_tools\",n.init_ClearTool()}\n//# sourceMappingURL=clear_tool.min.js.map","min_map":"{\"version\":3,\"sources\":[\"0\"],\"names\":[\"_\",\"require\",\"module\",\"exports\",\"__esModule\",\"__esExport\",\"p\",\"__importStar\",\"action_tool_1\",\"ClearToolView\",\"ActionToolView\",\"doit\",\"source\",\"this\",\"model\",\"sources\",\"column\",\"data\",\"change\",\"emit\",\"properties\",\"__name__\",\"ClearTool\",\"ActionTool\",\"constructor\",\"attrs\",\"super\",\"tool_name\",\"icon\",\"init_ClearTool\",\"prototype\",\"default_view\",\"define\",\"Array\",\"__module__\"],\"mappings\":\"AAA2B,SAASA,EAAEC,EAASC,EAAQC,EAASC,EAAYC,GACxED,IACA,MACME,GAAI,EADML,EAAQ,SACFM,cAAcN,EAAQ,6BACtCO,EAAgBP,EAAQ,6CAC9B,MAAMQ,UAAsBD,EAAcE,eACtCC,OACI,IAAK,IAAIC,KAAUC,KAAKC,MAAMC,QAAS,CACnC,IAAK,MAAMC,KAAUJ,EAAOK,KACxBL,EAAOK,KAAKD,GAAU,GAE1BJ,EAAOM,OAAOC,OACdP,EAAOQ,WAAWH,KAAKC,OAAOC,SAI1ChB,EAAQM,cAAgBA,EACxBA,EAAcY,SAAW,gBACzB,MAAMC,UAAkBd,EAAce,WAClCC,YAAYC,GACRC,MAAMD,GACNZ,KAAKc,UAAY,aACjBd,KAAKe,KAAO,qBAEhBC,wBACIhB,KAAKiB,UAAUC,aAAetB,EAC9BI,KAAKmB,OAAO,CACRjB,QAAS,CAACT,EAAE2B,MAAO,OAI/B9B,EAAQmB,UAAYA,EACpBA,EAAUD,SAAW,YACrBC,EAAUY,WAAa,+BACvBZ,EAAUO\",\"file\":\"clear_tool.min.js\"}"}},{"module":{"file":"/home/runner/work/geoviews/geoviews/geoviews/dist/lib/models/poly_draw.js","base":"/home/runner/work/geoviews/geoviews/geoviews/dist/lib","base_path":"models/poly_draw.js","canonical":"models/poly_draw","resolution":"ESM","id":"8288feb407","hash":"8288feb407b7be2c76fe139c20c56e74148c3ab79bdf3bb7c96b17afc061017f","source":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PolyVertexDrawTool = exports.PolyVertexDrawToolView = void 0;\nconst tslib_1 = require(\"tslib\");\nconst p = (0, tslib_1.__importStar)(require(\"@bokehjs/core/properties\"));\nconst object_1 = require(\"@bokehjs/core/util/object\");\nconst types_1 = require(\"@bokehjs/core/util/types\");\nconst poly_draw_tool_1 = require(\"@bokehjs/models/tools/edit/poly_draw_tool\");\nclass PolyVertexDrawToolView extends poly_draw_tool_1.PolyDrawToolView {\n    _split_path(x, y) {\n        for (let r = 0; r < this.model.renderers.length; r++) {\n            const renderer = this.model.renderers[r];\n            const glyph = renderer.glyph;\n            const cds = renderer.data_source;\n            const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n            const xpaths = cds.data[xkey];\n            const ypaths = cds.data[ykey];\n            for (let index = 0; index < xpaths.length; index++) {\n                let xs = xpaths[index];\n                if (!(0, types_1.isArray)(xs)) {\n                    xs = Array.from(xs);\n                    cds.data[xkey][index] = xs;\n                }\n                let ys = ypaths[index];\n                if (!(0, types_1.isArray)(ys)) {\n                    ys = Array.from(ys);\n                    cds.data[ykey][index] = ys;\n                }\n                for (let i = 0; i < xs.length; i++) {\n                    if ((xs[i] == x) && (ys[i] == y) && (i != 0) && (i != (xs.length - 1))) {\n                        xpaths.splice(index + 1, 0, xs.slice(i));\n                        ypaths.splice(index + 1, 0, ys.slice(i));\n                        xs.splice(i + 1);\n                        ys.splice(i + 1);\n                        for (const column of cds.columns()) {\n                            if ((column !== xkey) && (column != ykey))\n                                cds.data[column].splice(index + 1, 0, cds.data[column][index]);\n                        }\n                        return;\n                    }\n                }\n            }\n        }\n    }\n    _snap_to_vertex(ev, x, y) {\n        if (this.model.vertex_renderer) {\n            // If an existing vertex is hit snap to it\n            const vertex_selected = this._select_event(ev, \"replace\", [this.model.vertex_renderer]);\n            const point_ds = this.model.vertex_renderer.data_source;\n            // Type once dataspecs are typed\n            const point_glyph = this.model.vertex_renderer.glyph;\n            const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\n            if (vertex_selected.length) {\n                // If existing vertex is hit split path at that location\n                // converting to feature vertex\n                const index = point_ds.selected.indices[0];\n                if (pxkey)\n                    x = point_ds.data[pxkey][index];\n                if (pykey)\n                    y = point_ds.data[pykey][index];\n                if (ev.type != 'mousemove')\n                    this._split_path(x, y);\n                point_ds.selection_manager.clear();\n            }\n        }\n        return [x, y];\n    }\n    _set_vertices(xs, ys, styles) {\n        const point_glyph = this.model.vertex_renderer.glyph;\n        const point_cds = this.model.vertex_renderer.data_source;\n        const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\n        if (pxkey) {\n            if ((0, types_1.isArray)(xs))\n                point_cds.data[pxkey] = xs;\n            else\n                point_glyph.x = { value: xs };\n        }\n        if (pykey) {\n            if ((0, types_1.isArray)(ys))\n                point_cds.data[pykey] = ys;\n            else\n                point_glyph.y = { value: ys };\n        }\n        if (styles != null) {\n            for (const key of (0, object_1.keys)(styles)) {\n                point_cds.data[key] = styles[key];\n                point_glyph[key] = { field: key };\n            }\n        }\n        else {\n            for (const col of point_cds.columns()) {\n                point_cds.data[col] = [];\n            }\n        }\n        this._emit_cds_changes(point_cds, true, true, false);\n    }\n    _show_vertices() {\n        if (!this.model.active) {\n            return;\n        }\n        const xs = [];\n        const ys = [];\n        const styles = {};\n        for (const key of (0, object_1.keys)(this.model.end_style))\n            styles[key] = [];\n        for (let i = 0; i < this.model.renderers.length; i++) {\n            const renderer = this.model.renderers[i];\n            const cds = renderer.data_source;\n            const glyph = renderer.glyph;\n            const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n            for (const array of cds.get_array(xkey)) {\n                Array.prototype.push.apply(xs, array);\n                for (const key of (0, object_1.keys)(this.model.end_style))\n                    styles[key].push(this.model.end_style[key]);\n                for (const key of (0, object_1.keys)(this.model.node_style)) {\n                    for (let index = 0; index < (array.length - 2); index++) {\n                        styles[key].push(this.model.node_style[key]);\n                    }\n                }\n                for (const key of (0, object_1.keys)(this.model.end_style))\n                    styles[key].push(this.model.end_style[key]);\n            }\n            for (const array of cds.get_array(ykey))\n                Array.prototype.push.apply(ys, array);\n            if (this._drawing && (i == (this.model.renderers.length - 1))) {\n                // Skip currently drawn vertex\n                xs.splice(xs.length - 1, 1);\n                ys.splice(ys.length - 1, 1);\n                for (const key of (0, object_1.keys)(styles))\n                    styles[key].splice(styles[key].length - 1, 1);\n            }\n        }\n        this._set_vertices(xs, ys, styles);\n    }\n    _remove() {\n        const renderer = this.model.renderers[0];\n        const cds = renderer.data_source;\n        const glyph = renderer.glyph;\n        const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n        if (xkey) {\n            const xidx = cds.data[xkey].length - 1;\n            const xs = cds.get_array(xkey)[xidx];\n            xs.splice(xs.length - 1, 1);\n            if (xs.length == 1)\n                cds.data[xkey].splice(xidx, 1);\n        }\n        if (ykey) {\n            const yidx = cds.data[ykey].length - 1;\n            const ys = cds.get_array(ykey)[yidx];\n            ys.splice(ys.length - 1, 1);\n            if (ys.length == 1)\n                cds.data[ykey].splice(yidx, 1);\n        }\n        this._emit_cds_changes(cds);\n        this._drawing = false;\n        this._show_vertices();\n    }\n}\nexports.PolyVertexDrawToolView = PolyVertexDrawToolView;\nPolyVertexDrawToolView.__name__ = \"PolyVertexDrawToolView\";\nclass PolyVertexDrawTool extends poly_draw_tool_1.PolyDrawTool {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_PolyVertexDrawTool() {\n        this.prototype.default_view = PolyVertexDrawToolView;\n        this.define({\n            end_style: [p.Any, {}],\n            node_style: [p.Any, {}],\n        });\n    }\n}\nexports.PolyVertexDrawTool = PolyVertexDrawTool;\nPolyVertexDrawTool.__name__ = \"PolyVertexDrawTool\";\nPolyVertexDrawTool.__module__ = \"geoviews.models.custom_tools\";\nPolyVertexDrawTool.init_PolyVertexDrawTool();\n//# sourceMappingURL=poly_draw.js.map\n","type":"js","dependency_paths":[],"dependency_map":[],"exported":[{"type":"named","name":"PolyVertexDrawToolView"},{"type":"named","name":"PolyVertexDrawTool"}],"externals":[],"shims":[]},"code":{"source":"/* models/poly_draw.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    const tslib_1 = require(\"tslib\");\n    const p = (0, tslib_1.__importStar)(require(\"@bokehjs/core/properties\"));\n    const object_1 = require(\"@bokehjs/core/util/object\");\n    const types_1 = require(\"@bokehjs/core/util/types\");\n    const poly_draw_tool_1 = require(\"@bokehjs/models/tools/edit/poly_draw_tool\");\n    class PolyVertexDrawToolView extends poly_draw_tool_1.PolyDrawToolView {\n        _split_path(x, y) {\n            for (let r = 0; r < this.model.renderers.length; r++) {\n                const renderer = this.model.renderers[r];\n                const glyph = renderer.glyph;\n                const cds = renderer.data_source;\n                const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n                const xpaths = cds.data[xkey];\n                const ypaths = cds.data[ykey];\n                for (let index = 0; index < xpaths.length; index++) {\n                    let xs = xpaths[index];\n                    if (!(0, types_1.isArray)(xs)) {\n                        xs = Array.from(xs);\n                        cds.data[xkey][index] = xs;\n                    }\n                    let ys = ypaths[index];\n                    if (!(0, types_1.isArray)(ys)) {\n                        ys = Array.from(ys);\n                        cds.data[ykey][index] = ys;\n                    }\n                    for (let i = 0; i < xs.length; i++) {\n                        if ((xs[i] == x) && (ys[i] == y) && (i != 0) && (i != (xs.length - 1))) {\n                            xpaths.splice(index + 1, 0, xs.slice(i));\n                            ypaths.splice(index + 1, 0, ys.slice(i));\n                            xs.splice(i + 1);\n                            ys.splice(i + 1);\n                            for (const column of cds.columns()) {\n                                if ((column !== xkey) && (column != ykey))\n                                    cds.data[column].splice(index + 1, 0, cds.data[column][index]);\n                            }\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        _snap_to_vertex(ev, x, y) {\n            if (this.model.vertex_renderer) {\n                // If an existing vertex is hit snap to it\n                const vertex_selected = this._select_event(ev, \"replace\", [this.model.vertex_renderer]);\n                const point_ds = this.model.vertex_renderer.data_source;\n                // Type once dataspecs are typed\n                const point_glyph = this.model.vertex_renderer.glyph;\n                const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\n                if (vertex_selected.length) {\n                    // If existing vertex is hit split path at that location\n                    // converting to feature vertex\n                    const index = point_ds.selected.indices[0];\n                    if (pxkey)\n                        x = point_ds.data[pxkey][index];\n                    if (pykey)\n                        y = point_ds.data[pykey][index];\n                    if (ev.type != 'mousemove')\n                        this._split_path(x, y);\n                    point_ds.selection_manager.clear();\n                }\n            }\n            return [x, y];\n        }\n        _set_vertices(xs, ys, styles) {\n            const point_glyph = this.model.vertex_renderer.glyph;\n            const point_cds = this.model.vertex_renderer.data_source;\n            const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\n            if (pxkey) {\n                if ((0, types_1.isArray)(xs))\n                    point_cds.data[pxkey] = xs;\n                else\n                    point_glyph.x = { value: xs };\n            }\n            if (pykey) {\n                if ((0, types_1.isArray)(ys))\n                    point_cds.data[pykey] = ys;\n                else\n                    point_glyph.y = { value: ys };\n            }\n            if (styles != null) {\n                for (const key of (0, object_1.keys)(styles)) {\n                    point_cds.data[key] = styles[key];\n                    point_glyph[key] = { field: key };\n                }\n            }\n            else {\n                for (const col of point_cds.columns()) {\n                    point_cds.data[col] = [];\n                }\n            }\n            this._emit_cds_changes(point_cds, true, true, false);\n        }\n        _show_vertices() {\n            if (!this.model.active) {\n                return;\n            }\n            const xs = [];\n            const ys = [];\n            const styles = {};\n            for (const key of (0, object_1.keys)(this.model.end_style))\n                styles[key] = [];\n            for (let i = 0; i < this.model.renderers.length; i++) {\n                const renderer = this.model.renderers[i];\n                const cds = renderer.data_source;\n                const glyph = renderer.glyph;\n                const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n                for (const array of cds.get_array(xkey)) {\n                    Array.prototype.push.apply(xs, array);\n                    for (const key of (0, object_1.keys)(this.model.end_style))\n                        styles[key].push(this.model.end_style[key]);\n                    for (const key of (0, object_1.keys)(this.model.node_style)) {\n                        for (let index = 0; index < (array.length - 2); index++) {\n                            styles[key].push(this.model.node_style[key]);\n                        }\n                    }\n                    for (const key of (0, object_1.keys)(this.model.end_style))\n                        styles[key].push(this.model.end_style[key]);\n                }\n                for (const array of cds.get_array(ykey))\n                    Array.prototype.push.apply(ys, array);\n                if (this._drawing && (i == (this.model.renderers.length - 1))) {\n                    // Skip currently drawn vertex\n                    xs.splice(xs.length - 1, 1);\n                    ys.splice(ys.length - 1, 1);\n                    for (const key of (0, object_1.keys)(styles))\n                        styles[key].splice(styles[key].length - 1, 1);\n                }\n            }\n            this._set_vertices(xs, ys, styles);\n        }\n        _remove() {\n            const renderer = this.model.renderers[0];\n            const cds = renderer.data_source;\n            const glyph = renderer.glyph;\n            const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n            if (xkey) {\n                const xidx = cds.data[xkey].length - 1;\n                const xs = cds.get_array(xkey)[xidx];\n                xs.splice(xs.length - 1, 1);\n                if (xs.length == 1)\n                    cds.data[xkey].splice(xidx, 1);\n            }\n            if (ykey) {\n                const yidx = cds.data[ykey].length - 1;\n                const ys = cds.get_array(ykey)[yidx];\n                ys.splice(ys.length - 1, 1);\n                if (ys.length == 1)\n                    cds.data[ykey].splice(yidx, 1);\n            }\n            this._emit_cds_changes(cds);\n            this._drawing = false;\n            this._show_vertices();\n        }\n    }\n    exports.PolyVertexDrawToolView = PolyVertexDrawToolView;\n    PolyVertexDrawToolView.__name__ = \"PolyVertexDrawToolView\";\n    class PolyVertexDrawTool extends poly_draw_tool_1.PolyDrawTool {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_PolyVertexDrawTool() {\n            this.prototype.default_view = PolyVertexDrawToolView;\n            this.define({\n                end_style: [p.Any, {}],\n                node_style: [p.Any, {}],\n            });\n        }\n    }\n    exports.PolyVertexDrawTool = PolyVertexDrawTool;\n    PolyVertexDrawTool.__name__ = \"PolyVertexDrawTool\";\n    PolyVertexDrawTool.__module__ = \"geoviews.models.custom_tools\";\n    PolyVertexDrawTool.init_PolyVertexDrawTool();\n}\n","min_source":"function _(e,t,s,o,r){o();const l=(0,e(\"tslib\").__importStar)(e(\"@bokehjs/core/properties\")),i=e(\"@bokehjs/core/util/object\"),a=e(\"@bokehjs/core/util/types\"),d=e(\"@bokehjs/models/tools/edit/poly_draw_tool\");class n extends d.PolyDrawToolView{_split_path(e,t){for(let s=0;s<this.model.renderers.length;s++){const o=this.model.renderers[s],r=o.glyph,l=o.data_source,[i,d]=[r.xs.field,r.ys.field],n=l.data[i],_=l.data[d];for(let s=0;s<n.length;s++){let o=n[s];(0,a.isArray)(o)||(o=Array.from(o),l.data[i][s]=o);let r=_[s];(0,a.isArray)(r)||(r=Array.from(r),l.data[d][s]=r);for(let a=0;a<o.length;a++)if(o[a]==e&&r[a]==t&&0!=a&&a!=o.length-1){n.splice(s+1,0,o.slice(a)),_.splice(s+1,0,r.slice(a)),o.splice(a+1),r.splice(a+1);for(const e of l.columns())e!==i&&e!=d&&l.data[e].splice(s+1,0,l.data[e][s]);return}}}}_snap_to_vertex(e,t,s){if(this.model.vertex_renderer){const o=this._select_event(e,\"replace\",[this.model.vertex_renderer]),r=this.model.vertex_renderer.data_source,l=this.model.vertex_renderer.glyph,[i,a]=[l.x.field,l.y.field];if(o.length){const o=r.selected.indices[0];i&&(t=r.data[i][o]),a&&(s=r.data[a][o]),\"mousemove\"!=e.type&&this._split_path(t,s),r.selection_manager.clear()}}return[t,s]}_set_vertices(e,t,s){const o=this.model.vertex_renderer.glyph,r=this.model.vertex_renderer.data_source,[l,d]=[o.x.field,o.y.field];if(l&&((0,a.isArray)(e)?r.data[l]=e:o.x={value:e}),d&&((0,a.isArray)(t)?r.data[d]=t:o.y={value:t}),null!=s)for(const e of(0,i.keys)(s))r.data[e]=s[e],o[e]={field:e};else for(const e of r.columns())r.data[e]=[];this._emit_cds_changes(r,!0,!0,!1)}_show_vertices(){if(!this.model.active)return;const e=[],t=[],s={};for(const e of(0,i.keys)(this.model.end_style))s[e]=[];for(let o=0;o<this.model.renderers.length;o++){const r=this.model.renderers[o],l=r.data_source,a=r.glyph,[d,n]=[a.xs.field,a.ys.field];for(const t of l.get_array(d)){Array.prototype.push.apply(e,t);for(const e of(0,i.keys)(this.model.end_style))s[e].push(this.model.end_style[e]);for(const e of(0,i.keys)(this.model.node_style))for(let o=0;o<t.length-2;o++)s[e].push(this.model.node_style[e]);for(const e of(0,i.keys)(this.model.end_style))s[e].push(this.model.end_style[e])}for(const e of l.get_array(n))Array.prototype.push.apply(t,e);if(this._drawing&&o==this.model.renderers.length-1){e.splice(e.length-1,1),t.splice(t.length-1,1);for(const e of(0,i.keys)(s))s[e].splice(s[e].length-1,1)}}this._set_vertices(e,t,s)}_remove(){const e=this.model.renderers[0],t=e.data_source,s=e.glyph,[o,r]=[s.xs.field,s.ys.field];if(o){const e=t.data[o].length-1,s=t.get_array(o)[e];s.splice(s.length-1,1),1==s.length&&t.data[o].splice(e,1)}if(r){const e=t.data[r].length-1,s=t.get_array(r)[e];s.splice(s.length-1,1),1==s.length&&t.data[r].splice(e,1)}this._emit_cds_changes(t),this._drawing=!1,this._show_vertices()}}s.PolyVertexDrawToolView=n,n.__name__=\"PolyVertexDrawToolView\";class _ extends d.PolyDrawTool{constructor(e){super(e)}static init_PolyVertexDrawTool(){this.prototype.default_view=n,this.define({end_style:[l.Any,{}],node_style:[l.Any,{}]})}}s.PolyVertexDrawTool=_,_.__name__=\"PolyVertexDrawTool\",_.__module__=\"geoviews.models.custom_tools\",_.init_PolyVertexDrawTool()}\n//# sourceMappingURL=poly_draw.min.js.map","min_map":"{\"version\":3,\"sources\":[\"0\"],\"names\":[\"_\",\"require\",\"module\",\"exports\",\"__esModule\",\"__esExport\",\"p\",\"__importStar\",\"object_1\",\"types_1\",\"poly_draw_tool_1\",\"PolyVertexDrawToolView\",\"PolyDrawToolView\",\"_split_path\",\"x\",\"y\",\"r\",\"this\",\"model\",\"renderers\",\"length\",\"renderer\",\"glyph\",\"cds\",\"data_source\",\"xkey\",\"ykey\",\"xs\",\"field\",\"ys\",\"xpaths\",\"data\",\"ypaths\",\"index\",\"isArray\",\"Array\",\"from\",\"i\",\"splice\",\"slice\",\"column\",\"columns\",\"_snap_to_vertex\",\"ev\",\"vertex_renderer\",\"vertex_selected\",\"_select_event\",\"point_ds\",\"point_glyph\",\"pxkey\",\"pykey\",\"selected\",\"indices\",\"type\",\"selection_manager\",\"clear\",\"_set_vertices\",\"styles\",\"point_cds\",\"value\",\"key\",\"keys\",\"col\",\"_emit_cds_changes\",\"_show_vertices\",\"active\",\"end_style\",\"array\",\"get_array\",\"prototype\",\"push\",\"apply\",\"node_style\",\"_drawing\",\"_remove\",\"xidx\",\"yidx\",\"__name__\",\"PolyVertexDrawTool\",\"PolyDrawTool\",\"constructor\",\"attrs\",\"super\",\"init_PolyVertexDrawTool\",\"default_view\",\"define\",\"Any\",\"__module__\"],\"mappings\":\"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\",\"file\":\"poly_draw.min.js\"}"}},{"module":{"file":"/home/runner/work/geoviews/geoviews/geoviews/dist/lib/models/poly_edit.js","base":"/home/runner/work/geoviews/geoviews/geoviews/dist/lib","base_path":"models/poly_edit.js","canonical":"models/poly_edit","resolution":"ESM","id":"5e7ea505ce","hash":"5e7ea505cecf26e772d69c23da4fae95b3ff68dc1136cba8ebf1aefcddbc5cec","source":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PolyVertexEditTool = exports.PolyVertexEditToolView = void 0;\nconst tslib_1 = require(\"tslib\");\nconst p = (0, tslib_1.__importStar)(require(\"@bokehjs/core/properties\"));\nconst object_1 = require(\"@bokehjs/core/util/object\");\nconst types_1 = require(\"@bokehjs/core/util/types\");\nconst poly_edit_tool_1 = require(\"@bokehjs/models/tools/edit/poly_edit_tool\");\nclass PolyVertexEditToolView extends poly_edit_tool_1.PolyEditToolView {\n    deactivate() {\n        this._hide_vertices();\n        if (!this._selected_renderer) {\n            return;\n        }\n        else if (this._drawing) {\n            this._remove_vertex();\n            this._drawing = false;\n        }\n        this._emit_cds_changes(this._selected_renderer.data_source, false, true, false);\n    }\n    _pan(ev) {\n        if (this._basepoint == null)\n            return;\n        const points = this._drag_points(ev, [this.model.vertex_renderer]);\n        if (!ev.shiftKey) {\n            this._move_linked(points);\n        }\n        if (this._selected_renderer)\n            this._selected_renderer.data_source.change.emit();\n    }\n    _pan_end(ev) {\n        if (this._basepoint == null)\n            return;\n        const points = this._drag_points(ev, [this.model.vertex_renderer]);\n        if (!ev.shiftKey) {\n            this._move_linked(points);\n        }\n        this._emit_cds_changes(this.model.vertex_renderer.data_source, false, true, true);\n        if (this._selected_renderer) {\n            this._emit_cds_changes(this._selected_renderer.data_source);\n        }\n        this._basepoint = null;\n    }\n    _drag_points(ev, renderers) {\n        if (this._basepoint == null)\n            return [];\n        const [bx, by] = this._basepoint;\n        const points = [];\n        for (const renderer of renderers) {\n            const basepoint = this._map_drag(bx, by, renderer);\n            const point = this._map_drag(ev.sx, ev.sy, renderer);\n            if (point == null || basepoint == null) {\n                continue;\n            }\n            const [x, y] = point;\n            const [px, py] = basepoint;\n            const [dx, dy] = [x - px, y - py];\n            // Type once dataspecs are typed\n            const glyph = renderer.glyph;\n            const cds = renderer.data_source;\n            const [xkey, ykey] = [glyph.x.field, glyph.y.field];\n            for (const index of cds.selected.indices) {\n                const point = [];\n                if (xkey) {\n                    point.push(cds.data[xkey][index]);\n                    cds.data[xkey][index] += dx;\n                }\n                if (ykey) {\n                    point.push(cds.data[ykey][index]);\n                    cds.data[ykey][index] += dy;\n                }\n                point.push(dx);\n                point.push(dy);\n                points.push(point);\n            }\n            cds.change.emit();\n        }\n        this._basepoint = [ev.sx, ev.sy];\n        return points;\n    }\n    _set_vertices(xs, ys, styles) {\n        const point_glyph = this.model.vertex_renderer.glyph;\n        const point_cds = this.model.vertex_renderer.data_source;\n        const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\n        if (pxkey) {\n            if ((0, types_1.isArray)(xs))\n                point_cds.data[pxkey] = xs;\n            else\n                point_glyph.x = { value: xs };\n        }\n        if (pykey) {\n            if ((0, types_1.isArray)(ys))\n                point_cds.data[pykey] = ys;\n            else\n                point_glyph.y = { value: ys };\n        }\n        if (styles != null) {\n            for (const key of (0, object_1.keys)(styles)) {\n                point_cds.data[key] = styles[key];\n                point_glyph[key] = { field: key };\n            }\n        }\n        else {\n            for (const col of point_cds.columns()) {\n                point_cds.data[col] = [];\n            }\n        }\n        this._emit_cds_changes(point_cds, true, true, false);\n    }\n    _move_linked(points) {\n        if (!this._selected_renderer)\n            return;\n        const renderer = this._selected_renderer;\n        const glyph = renderer.glyph;\n        const cds = renderer.data_source;\n        const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n        const xpaths = cds.data[xkey];\n        const ypaths = cds.data[ykey];\n        for (const point of points) {\n            const [x, y, dx, dy] = point;\n            for (let index = 0; index < xpaths.length; index++) {\n                const xs = xpaths[index];\n                const ys = ypaths[index];\n                for (let i = 0; i < xs.length; i++) {\n                    if ((xs[i] == x) && (ys[i] == y)) {\n                        xs[i] += dx;\n                        ys[i] += dy;\n                    }\n                }\n            }\n        }\n    }\n    _tap(ev) {\n        const renderer = this.model.vertex_renderer;\n        const point = this._map_drag(ev.sx, ev.sy, renderer);\n        if (point == null)\n            return;\n        else if (this._drawing && this._selected_renderer) {\n            let [x, y] = point;\n            const cds = renderer.data_source;\n            // Type once dataspecs are typed\n            const glyph = renderer.glyph;\n            const [xkey, ykey] = [glyph.x.field, glyph.y.field];\n            const indices = cds.selected.indices;\n            [x, y] = this._snap_to_vertex(ev, x, y);\n            const index = indices[0];\n            cds.selected.indices = [index + 1];\n            if (xkey) {\n                const xs = cds.get_array(xkey);\n                const nx = xs[index];\n                xs[index] = x;\n                xs.splice(index + 1, 0, nx);\n            }\n            if (ykey) {\n                const ys = cds.get_array(ykey);\n                const ny = ys[index];\n                ys[index] = y;\n                ys.splice(index + 1, 0, ny);\n            }\n            cds.change.emit();\n            this._emit_cds_changes(this._selected_renderer.data_source, true, false, true);\n            return;\n        }\n        this._select_event(ev, this._select_mode(ev), [renderer]);\n    }\n    _show_vertices(ev) {\n        if (!this.model.active)\n            return;\n        const renderers = this._select_event(ev, \"replace\", this.model.renderers);\n        if (!renderers.length) {\n            this._hide_vertices();\n            this._selected_renderer = null;\n            this._drawing = false;\n            return;\n        }\n        const renderer = renderers[0];\n        const glyph = renderer.glyph;\n        const cds = renderer.data_source;\n        const index = cds.selected.indices[0];\n        const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n        let xs;\n        let ys;\n        if (xkey) {\n            xs = cds.data[xkey][index];\n            if (!(0, types_1.isArray)(xs))\n                cds.data[xkey][index] = xs = Array.from(xs);\n        }\n        else {\n            xs = glyph.xs.value;\n        }\n        if (ykey) {\n            ys = cds.data[ykey][index];\n            if (!(0, types_1.isArray)(ys))\n                cds.data[ykey][index] = ys = Array.from(ys);\n        }\n        else {\n            ys = glyph.ys.value;\n        }\n        const styles = {};\n        for (const key of (0, object_1.keys)(this.model.end_style))\n            styles[key] = [this.model.end_style[key]];\n        for (const key of (0, object_1.keys)(this.model.node_style)) {\n            for (let index = 0; index < (xs.length - 2); index++) {\n                styles[key].push(this.model.node_style[key]);\n            }\n        }\n        for (const key of (0, object_1.keys)(this.model.end_style))\n            styles[key].push(this.model.end_style[key]);\n        this._selected_renderer = renderer;\n        this._set_vertices(xs, ys, styles);\n    }\n}\nexports.PolyVertexEditToolView = PolyVertexEditToolView;\nPolyVertexEditToolView.__name__ = \"PolyVertexEditToolView\";\nclass PolyVertexEditTool extends poly_edit_tool_1.PolyEditTool {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_PolyVertexEditTool() {\n        this.prototype.default_view = PolyVertexEditToolView;\n        this.define({\n            node_style: [p.Any, {}],\n            end_style: [p.Any, {}],\n        });\n    }\n}\nexports.PolyVertexEditTool = PolyVertexEditTool;\nPolyVertexEditTool.__name__ = \"PolyVertexEditTool\";\nPolyVertexEditTool.__module__ = \"geoviews.models.custom_tools\";\nPolyVertexEditTool.init_PolyVertexEditTool();\n//# sourceMappingURL=poly_edit.js.map\n","type":"js","dependency_paths":[],"dependency_map":[],"exported":[{"type":"named","name":"PolyVertexEditToolView"},{"type":"named","name":"PolyVertexEditTool"}],"externals":[],"shims":[]},"code":{"source":"/* models/poly_edit.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    const tslib_1 = require(\"tslib\");\n    const p = (0, tslib_1.__importStar)(require(\"@bokehjs/core/properties\"));\n    const object_1 = require(\"@bokehjs/core/util/object\");\n    const types_1 = require(\"@bokehjs/core/util/types\");\n    const poly_edit_tool_1 = require(\"@bokehjs/models/tools/edit/poly_edit_tool\");\n    class PolyVertexEditToolView extends poly_edit_tool_1.PolyEditToolView {\n        deactivate() {\n            this._hide_vertices();\n            if (!this._selected_renderer) {\n                return;\n            }\n            else if (this._drawing) {\n                this._remove_vertex();\n                this._drawing = false;\n            }\n            this._emit_cds_changes(this._selected_renderer.data_source, false, true, false);\n        }\n        _pan(ev) {\n            if (this._basepoint == null)\n                return;\n            const points = this._drag_points(ev, [this.model.vertex_renderer]);\n            if (!ev.shiftKey) {\n                this._move_linked(points);\n            }\n            if (this._selected_renderer)\n                this._selected_renderer.data_source.change.emit();\n        }\n        _pan_end(ev) {\n            if (this._basepoint == null)\n                return;\n            const points = this._drag_points(ev, [this.model.vertex_renderer]);\n            if (!ev.shiftKey) {\n                this._move_linked(points);\n            }\n            this._emit_cds_changes(this.model.vertex_renderer.data_source, false, true, true);\n            if (this._selected_renderer) {\n                this._emit_cds_changes(this._selected_renderer.data_source);\n            }\n            this._basepoint = null;\n        }\n        _drag_points(ev, renderers) {\n            if (this._basepoint == null)\n                return [];\n            const [bx, by] = this._basepoint;\n            const points = [];\n            for (const renderer of renderers) {\n                const basepoint = this._map_drag(bx, by, renderer);\n                const point = this._map_drag(ev.sx, ev.sy, renderer);\n                if (point == null || basepoint == null) {\n                    continue;\n                }\n                const [x, y] = point;\n                const [px, py] = basepoint;\n                const [dx, dy] = [x - px, y - py];\n                // Type once dataspecs are typed\n                const glyph = renderer.glyph;\n                const cds = renderer.data_source;\n                const [xkey, ykey] = [glyph.x.field, glyph.y.field];\n                for (const index of cds.selected.indices) {\n                    const point = [];\n                    if (xkey) {\n                        point.push(cds.data[xkey][index]);\n                        cds.data[xkey][index] += dx;\n                    }\n                    if (ykey) {\n                        point.push(cds.data[ykey][index]);\n                        cds.data[ykey][index] += dy;\n                    }\n                    point.push(dx);\n                    point.push(dy);\n                    points.push(point);\n                }\n                cds.change.emit();\n            }\n            this._basepoint = [ev.sx, ev.sy];\n            return points;\n        }\n        _set_vertices(xs, ys, styles) {\n            const point_glyph = this.model.vertex_renderer.glyph;\n            const point_cds = this.model.vertex_renderer.data_source;\n            const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\n            if (pxkey) {\n                if ((0, types_1.isArray)(xs))\n                    point_cds.data[pxkey] = xs;\n                else\n                    point_glyph.x = { value: xs };\n            }\n            if (pykey) {\n                if ((0, types_1.isArray)(ys))\n                    point_cds.data[pykey] = ys;\n                else\n                    point_glyph.y = { value: ys };\n            }\n            if (styles != null) {\n                for (const key of (0, object_1.keys)(styles)) {\n                    point_cds.data[key] = styles[key];\n                    point_glyph[key] = { field: key };\n                }\n            }\n            else {\n                for (const col of point_cds.columns()) {\n                    point_cds.data[col] = [];\n                }\n            }\n            this._emit_cds_changes(point_cds, true, true, false);\n        }\n        _move_linked(points) {\n            if (!this._selected_renderer)\n                return;\n            const renderer = this._selected_renderer;\n            const glyph = renderer.glyph;\n            const cds = renderer.data_source;\n            const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n            const xpaths = cds.data[xkey];\n            const ypaths = cds.data[ykey];\n            for (const point of points) {\n                const [x, y, dx, dy] = point;\n                for (let index = 0; index < xpaths.length; index++) {\n                    const xs = xpaths[index];\n                    const ys = ypaths[index];\n                    for (let i = 0; i < xs.length; i++) {\n                        if ((xs[i] == x) && (ys[i] == y)) {\n                            xs[i] += dx;\n                            ys[i] += dy;\n                        }\n                    }\n                }\n            }\n        }\n        _tap(ev) {\n            const renderer = this.model.vertex_renderer;\n            const point = this._map_drag(ev.sx, ev.sy, renderer);\n            if (point == null)\n                return;\n            else if (this._drawing && this._selected_renderer) {\n                let [x, y] = point;\n                const cds = renderer.data_source;\n                // Type once dataspecs are typed\n                const glyph = renderer.glyph;\n                const [xkey, ykey] = [glyph.x.field, glyph.y.field];\n                const indices = cds.selected.indices;\n                [x, y] = this._snap_to_vertex(ev, x, y);\n                const index = indices[0];\n                cds.selected.indices = [index + 1];\n                if (xkey) {\n                    const xs = cds.get_array(xkey);\n                    const nx = xs[index];\n                    xs[index] = x;\n                    xs.splice(index + 1, 0, nx);\n                }\n                if (ykey) {\n                    const ys = cds.get_array(ykey);\n                    const ny = ys[index];\n                    ys[index] = y;\n                    ys.splice(index + 1, 0, ny);\n                }\n                cds.change.emit();\n                this._emit_cds_changes(this._selected_renderer.data_source, true, false, true);\n                return;\n            }\n            this._select_event(ev, this._select_mode(ev), [renderer]);\n        }\n        _show_vertices(ev) {\n            if (!this.model.active)\n                return;\n            const renderers = this._select_event(ev, \"replace\", this.model.renderers);\n            if (!renderers.length) {\n                this._hide_vertices();\n                this._selected_renderer = null;\n                this._drawing = false;\n                return;\n            }\n            const renderer = renderers[0];\n            const glyph = renderer.glyph;\n            const cds = renderer.data_source;\n            const index = cds.selected.indices[0];\n            const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n            let xs;\n            let ys;\n            if (xkey) {\n                xs = cds.data[xkey][index];\n                if (!(0, types_1.isArray)(xs))\n                    cds.data[xkey][index] = xs = Array.from(xs);\n            }\n            else {\n                xs = glyph.xs.value;\n            }\n            if (ykey) {\n                ys = cds.data[ykey][index];\n                if (!(0, types_1.isArray)(ys))\n                    cds.data[ykey][index] = ys = Array.from(ys);\n            }\n            else {\n                ys = glyph.ys.value;\n            }\n            const styles = {};\n            for (const key of (0, object_1.keys)(this.model.end_style))\n                styles[key] = [this.model.end_style[key]];\n            for (const key of (0, object_1.keys)(this.model.node_style)) {\n                for (let index = 0; index < (xs.length - 2); index++) {\n                    styles[key].push(this.model.node_style[key]);\n                }\n            }\n            for (const key of (0, object_1.keys)(this.model.end_style))\n                styles[key].push(this.model.end_style[key]);\n            this._selected_renderer = renderer;\n            this._set_vertices(xs, ys, styles);\n        }\n    }\n    exports.PolyVertexEditToolView = PolyVertexEditToolView;\n    PolyVertexEditToolView.__name__ = \"PolyVertexEditToolView\";\n    class PolyVertexEditTool extends poly_edit_tool_1.PolyEditTool {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_PolyVertexEditTool() {\n            this.prototype.default_view = PolyVertexEditToolView;\n            this.define({\n                node_style: [p.Any, {}],\n                end_style: [p.Any, {}],\n            });\n        }\n    }\n    exports.PolyVertexEditTool = PolyVertexEditTool;\n    PolyVertexEditTool.__name__ = \"PolyVertexEditTool\";\n    PolyVertexEditTool.__module__ = \"geoviews.models.custom_tools\";\n    PolyVertexEditTool.init_PolyVertexEditTool();\n}\n","min_source":"function _(e,t,s,i,r){i();const o=(0,e(\"tslib\").__importStar)(e(\"@bokehjs/core/properties\")),_=e(\"@bokehjs/core/util/object\"),d=e(\"@bokehjs/core/util/types\"),l=e(\"@bokehjs/models/tools/edit/poly_edit_tool\");class n extends l.PolyEditToolView{deactivate(){this._hide_vertices(),this._selected_renderer&&(this._drawing&&(this._remove_vertex(),this._drawing=!1),this._emit_cds_changes(this._selected_renderer.data_source,!1,!0,!1))}_pan(e){if(null==this._basepoint)return;const t=this._drag_points(e,[this.model.vertex_renderer]);e.shiftKey||this._move_linked(t),this._selected_renderer&&this._selected_renderer.data_source.change.emit()}_pan_end(e){if(null==this._basepoint)return;const t=this._drag_points(e,[this.model.vertex_renderer]);e.shiftKey||this._move_linked(t),this._emit_cds_changes(this.model.vertex_renderer.data_source,!1,!0,!0),this._selected_renderer&&this._emit_cds_changes(this._selected_renderer.data_source),this._basepoint=null}_drag_points(e,t){if(null==this._basepoint)return[];const[s,i]=this._basepoint,r=[];for(const o of t){const t=this._map_drag(s,i,o),_=this._map_drag(e.sx,e.sy,o);if(null==_||null==t)continue;const[d,l]=_,[n,a]=t,[c,h]=[d-n,l-a],y=o.glyph,f=o.data_source,[u,m]=[y.x.field,y.y.field];for(const e of f.selected.indices){const t=[];u&&(t.push(f.data[u][e]),f.data[u][e]+=c),m&&(t.push(f.data[m][e]),f.data[m][e]+=h),t.push(c),t.push(h),r.push(t)}f.change.emit()}return this._basepoint=[e.sx,e.sy],r}_set_vertices(e,t,s){const i=this.model.vertex_renderer.glyph,r=this.model.vertex_renderer.data_source,[o,l]=[i.x.field,i.y.field];if(o&&((0,d.isArray)(e)?r.data[o]=e:i.x={value:e}),l&&((0,d.isArray)(t)?r.data[l]=t:i.y={value:t}),null!=s)for(const e of(0,_.keys)(s))r.data[e]=s[e],i[e]={field:e};else for(const e of r.columns())r.data[e]=[];this._emit_cds_changes(r,!0,!0,!1)}_move_linked(e){if(!this._selected_renderer)return;const t=this._selected_renderer,s=t.glyph,i=t.data_source,[r,o]=[s.xs.field,s.ys.field],_=i.data[r],d=i.data[o];for(const t of e){const[e,s,i,r]=t;for(let t=0;t<_.length;t++){const o=_[t],l=d[t];for(let t=0;t<o.length;t++)o[t]==e&&l[t]==s&&(o[t]+=i,l[t]+=r)}}}_tap(e){const t=this.model.vertex_renderer,s=this._map_drag(e.sx,e.sy,t);if(null!=s){if(this._drawing&&this._selected_renderer){let[i,r]=s;const o=t.data_source,_=t.glyph,[d,l]=[_.x.field,_.y.field],n=o.selected.indices;[i,r]=this._snap_to_vertex(e,i,r);const a=n[0];if(o.selected.indices=[a+1],d){const e=o.get_array(d),t=e[a];e[a]=i,e.splice(a+1,0,t)}if(l){const e=o.get_array(l),t=e[a];e[a]=r,e.splice(a+1,0,t)}return o.change.emit(),void this._emit_cds_changes(this._selected_renderer.data_source,!0,!1,!0)}this._select_event(e,this._select_mode(e),[t])}}_show_vertices(e){if(!this.model.active)return;const t=this._select_event(e,\"replace\",this.model.renderers);if(!t.length)return this._hide_vertices(),this._selected_renderer=null,void(this._drawing=!1);const s=t[0],i=s.glyph,r=s.data_source,o=r.selected.indices[0],[l,n]=[i.xs.field,i.ys.field];let a,c;l?(a=r.data[l][o],(0,d.isArray)(a)||(r.data[l][o]=a=Array.from(a))):a=i.xs.value,n?(c=r.data[n][o],(0,d.isArray)(c)||(r.data[n][o]=c=Array.from(c))):c=i.ys.value;const h={};for(const e of(0,_.keys)(this.model.end_style))h[e]=[this.model.end_style[e]];for(const e of(0,_.keys)(this.model.node_style))for(let t=0;t<a.length-2;t++)h[e].push(this.model.node_style[e]);for(const e of(0,_.keys)(this.model.end_style))h[e].push(this.model.end_style[e]);this._selected_renderer=s,this._set_vertices(a,c,h)}}s.PolyVertexEditToolView=n,n.__name__=\"PolyVertexEditToolView\";class a extends l.PolyEditTool{constructor(e){super(e)}static init_PolyVertexEditTool(){this.prototype.default_view=n,this.define({node_style:[o.Any,{}],end_style:[o.Any,{}]})}}s.PolyVertexEditTool=a,a.__name__=\"PolyVertexEditTool\",a.__module__=\"geoviews.models.custom_tools\",a.init_PolyVertexEditTool()}\n//# sourceMappingURL=poly_edit.min.js.map","min_map":"{\"version\":3,\"sources\":[\"0\"],\"names\":[\"_\",\"require\",\"module\",\"exports\",\"__esModule\",\"__esExport\",\"p\",\"__importStar\",\"object_1\",\"types_1\",\"poly_edit_tool_1\",\"PolyVertexEditToolView\",\"PolyEditToolView\",\"deactivate\",\"this\",\"_hide_vertices\",\"_selected_renderer\",\"_drawing\",\"_remove_vertex\",\"_emit_cds_changes\",\"data_source\",\"_pan\",\"ev\",\"_basepoint\",\"points\",\"_drag_points\",\"model\",\"vertex_renderer\",\"shiftKey\",\"_move_linked\",\"change\",\"emit\",\"_pan_end\",\"renderers\",\"bx\",\"by\",\"renderer\",\"basepoint\",\"_map_drag\",\"point\",\"sx\",\"sy\",\"x\",\"y\",\"px\",\"py\",\"dx\",\"dy\",\"glyph\",\"cds\",\"xkey\",\"ykey\",\"field\",\"index\",\"selected\",\"indices\",\"push\",\"data\",\"_set_vertices\",\"xs\",\"ys\",\"styles\",\"point_glyph\",\"point_cds\",\"pxkey\",\"pykey\",\"isArray\",\"value\",\"key\",\"keys\",\"col\",\"columns\",\"xpaths\",\"ypaths\",\"length\",\"i\",\"_tap\",\"_snap_to_vertex\",\"get_array\",\"nx\",\"splice\",\"ny\",\"_select_event\",\"_select_mode\",\"_show_vertices\",\"active\",\"Array\",\"from\",\"end_style\",\"node_style\",\"__name__\",\"PolyVertexEditTool\",\"PolyEditTool\",\"constructor\",\"attrs\",\"super\",\"init_PolyVertexEditTool\",\"prototype\",\"default_view\",\"define\",\"Any\",\"__module__\"],\"mappings\":\"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\",\"file\":\"poly_edit.min.js\"}"}},{"module":{"file":"/home/runner/work/geoviews/geoviews/geoviews/dist/lib/models/restore_tool.js","base":"/home/runner/work/geoviews/geoviews/geoviews/dist/lib","base_path":"models/restore_tool.js","canonical":"models/restore_tool","resolution":"ESM","id":"e81e0595cf","hash":"e81e0595cf99e9f29a410ac148f153e3070632d0328343716f46a40ec1333267","source":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RestoreTool = exports.RestoreToolView = void 0;\nconst tslib_1 = require(\"tslib\");\nconst p = (0, tslib_1.__importStar)(require(\"@bokehjs/core/properties\"));\nconst action_tool_1 = require(\"@bokehjs/models/tools/actions/action_tool\");\nclass RestoreToolView extends action_tool_1.ActionToolView {\n    doit() {\n        const sources = this.model.sources;\n        for (const source of sources) {\n            if (!source.buffer || (source.buffer.length == 0)) {\n                continue;\n            }\n            source.data = source.buffer.pop();\n            source.change.emit();\n            source.properties.data.change.emit();\n        }\n    }\n}\nexports.RestoreToolView = RestoreToolView;\nRestoreToolView.__name__ = \"RestoreToolView\";\nclass RestoreTool extends action_tool_1.ActionTool {\n    constructor(attrs) {\n        super(attrs);\n        this.tool_name = \"Restore\";\n        this.icon = \"bk-tool-icon-undo\";\n    }\n    static init_RestoreTool() {\n        this.prototype.default_view = RestoreToolView;\n        this.define({\n            sources: [p.Array, []]\n        });\n    }\n}\nexports.RestoreTool = RestoreTool;\nRestoreTool.__name__ = \"RestoreTool\";\nRestoreTool.__module__ = \"geoviews.models.custom_tools\";\nRestoreTool.init_RestoreTool();\n//# sourceMappingURL=restore_tool.js.map\n","type":"js","dependency_paths":[],"dependency_map":[],"exported":[{"type":"named","name":"RestoreToolView"},{"type":"named","name":"RestoreTool"}],"externals":[],"shims":[]},"code":{"source":"/* models/restore_tool.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    const tslib_1 = require(\"tslib\");\n    const p = (0, tslib_1.__importStar)(require(\"@bokehjs/core/properties\"));\n    const action_tool_1 = require(\"@bokehjs/models/tools/actions/action_tool\");\n    class RestoreToolView extends action_tool_1.ActionToolView {\n        doit() {\n            const sources = this.model.sources;\n            for (const source of sources) {\n                if (!source.buffer || (source.buffer.length == 0)) {\n                    continue;\n                }\n                source.data = source.buffer.pop();\n                source.change.emit();\n                source.properties.data.change.emit();\n            }\n        }\n    }\n    exports.RestoreToolView = RestoreToolView;\n    RestoreToolView.__name__ = \"RestoreToolView\";\n    class RestoreTool extends action_tool_1.ActionTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Restore\";\n            this.icon = \"bk-tool-icon-undo\";\n        }\n        static init_RestoreTool() {\n            this.prototype.default_view = RestoreToolView;\n            this.define({\n                sources: [p.Array, []]\n            });\n        }\n    }\n    exports.RestoreTool = RestoreTool;\n    RestoreTool.__name__ = \"RestoreTool\";\n    RestoreTool.__module__ = \"geoviews.models.custom_tools\";\n    RestoreTool.init_RestoreTool();\n}\n","min_source":"function _(o,e,t,s,i){s();const r=(0,o(\"tslib\").__importStar)(o(\"@bokehjs/core/properties\")),n=o(\"@bokehjs/models/tools/actions/action_tool\");class l extends n.ActionToolView{doit(){const o=this.model.sources;for(const e of o)e.buffer&&0!=e.buffer.length&&(e.data=e.buffer.pop(),e.change.emit(),e.properties.data.change.emit())}}t.RestoreToolView=l,l.__name__=\"RestoreToolView\";class c extends n.ActionTool{constructor(o){super(o),this.tool_name=\"Restore\",this.icon=\"bk-tool-icon-undo\"}static init_RestoreTool(){this.prototype.default_view=l,this.define({sources:[r.Array,[]]})}}t.RestoreTool=c,c.__name__=\"RestoreTool\",c.__module__=\"geoviews.models.custom_tools\",c.init_RestoreTool()}\n//# sourceMappingURL=restore_tool.min.js.map","min_map":"{\"version\":3,\"sources\":[\"0\"],\"names\":[\"_\",\"require\",\"module\",\"exports\",\"__esModule\",\"__esExport\",\"p\",\"__importStar\",\"action_tool_1\",\"RestoreToolView\",\"ActionToolView\",\"doit\",\"sources\",\"this\",\"model\",\"source\",\"buffer\",\"length\",\"data\",\"pop\",\"change\",\"emit\",\"properties\",\"__name__\",\"RestoreTool\",\"ActionTool\",\"constructor\",\"attrs\",\"super\",\"tool_name\",\"icon\",\"init_RestoreTool\",\"prototype\",\"default_view\",\"define\",\"Array\",\"__module__\"],\"mappings\":\"AAA6B,SAASA,EAAEC,EAASC,EAAQC,EAASC,EAAYC,GAC1ED,IACA,MACME,GAAI,EADML,EAAQ,SACFM,cAAcN,EAAQ,6BACtCO,EAAgBP,EAAQ,6CAC9B,MAAMQ,UAAwBD,EAAcE,eACxCC,OACI,MAAMC,EAAUC,KAAKC,MAAMF,QAC3B,IAAK,MAAMG,KAAUH,EACZG,EAAOC,QAAmC,GAAxBD,EAAOC,OAAOC,SAGrCF,EAAOG,KAAOH,EAAOC,OAAOG,MAC5BJ,EAAOK,OAAOC,OACdN,EAAOO,WAAWJ,KAAKE,OAAOC,SAI1ClB,EAAQM,gBAAkBA,EAC1BA,EAAgBc,SAAW,kBAC3B,MAAMC,UAAoBhB,EAAciB,WACpCC,YAAYC,GACRC,MAAMD,GACNd,KAAKgB,UAAY,UACjBhB,KAAKiB,KAAO,oBAEhBC,0BACIlB,KAAKmB,UAAUC,aAAexB,EAC9BI,KAAKqB,OAAO,CACRtB,QAAS,CAACN,EAAE6B,MAAO,OAI/BhC,EAAQqB,YAAcA,EACtBA,EAAYD,SAAW,cACvBC,EAAYY,WAAa,+BACzBZ,EAAYO\",\"file\":\"restore_tool.min.js\"}"}}]}